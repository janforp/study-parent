package com.janita.datastructuresandalgorithms.bookofdjh.chapter4_tree;

/**
 * 书的
 *
 * @author zhucj
 * @since 20201126
 */
public class 树的一些定义推论 {

    /**
     * #############################################- 结论四.14 -#################################################################
     * 观察结论四.14二叉树中，除中序遍历序列中的首节点外，任一节点 v 的直接前驱 u 不外乎三种可能:
     * 1.v 没有左孩子，同时 v 是右孩子:此时，u 就是 v 的父亲节点;
     * 2.v 没有左孩子，同时 v 是左孩子:此时，从 v 出发沿 parent 引用逆行向上，直到第一个是右孩子 的节点 w，则 u 就是 w 的父亲节点;
     * 3.v 有左孩子:此时，从 v 的左孩子出发，沿 rChild 引用不断下行，最后一个(没有右孩子的)节 点就是 u。
     *
     *
     * #############################################- 定理四.2 -#################################################################
     * 定理四.2 在完全二叉树中，
     * 1.若节点 v 有左孩子，则 i(lchild(v)) = 2×i(v) + 1;
     * 2.若节点 v 有右孩子，则 i(rchild(v)) = 2×i(v) + 2;
     * 3.若节点 v 有父节点，则 i(parent(v)) = ⎣(i(v) - 1)/2⎦ = ⎡(i(v)/2⎤ - 1。
     *
     *
     * #############################################- 观察结论四.15 -#################################################################
     * 观察结论四.15 若基于可扩充向量来实现完全二叉树，则就分摊复杂度而言，每次 addLast()和
     * delLast()操作都可以在 O(1)时间内完成。
     */
    private static final int INT = 1;
}